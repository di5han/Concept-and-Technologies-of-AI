# -*- coding: utf-8 -*-
"""Worksheet0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V7ZfVxNtAcZLcGDIaxx_38uV_E6VsZzC

# 5CS037 - Worksheet 0  
### Python Essentials for Machine Learning
"""

# Daily time (in hours): [study, entertainment, sleep]

time_data = [
    (3.5, 2.0, 7.0), (5.0, 1.5, 6.5), (2.5, 3.0, 8.0),
    (4.0, 2.0, 6.0), (1.5, 4.5, 9.0), (3.0, 2.5, 7.5),
    (5.5, 1.0, 6.0), (2.0, 3.5, 8.5), (4.5, 2.0, 7.0),
    (3.0, 3.0, 7.5), (6.0, 1.5, 6.0), (2.5, 4.0, 8.0),
    (4.0, 2.5, 7.0), (5.0, 2.0, 6.5), (3.5, 2.5, 7.0)
]

low = []
moderate = []
high = []

for day in time_data:
    study = day[0]

    if study < 3:
        low.append(study)
    elif study >= 3 and study <= 5:
        moderate.append(study)
    else:
        high.append(study)

print("Low study:", low)
print("Moderate study:", moderate)
print("High study:", high)

print("Days with LOW study:", len(low))
print("Days with MODERATE study:", len(moderate))
print("Days with HIGH study:", len(high))

study_minutes = []

for day in time_data:
    study = day[0]
    minutes = study * 60
    study_minutes.append(minutes)

print("Study minutes:", study_minutes)

study_hours = []
entertainment_hours = []
sleep_hours = []

for study, ent, sleep in time_data:
    study_hours.append(study)
    entertainment_hours.append(ent)
    sleep_hours.append(sleep)

avg_study = sum(study_hours) / len(study_hours)
avg_ent = sum(entertainment_hours) / len(entertainment_hours)
avg_sleep = sum(sleep_hours) / len(sleep_hours)

print("Average study hours:", avg_study)
print("Average entertainment hours:", avg_ent)
print("Average sleep hours:", avg_sleep)

import matplotlib.pyplot as plt

study = [d[0] for d in time_data]
sleep = [d[2] for d in time_data]

plt.scatter(study, sleep)
plt.xlabel("Study Hours")
plt.ylabel("Sleep Hours")
plt.title("Study vs Sleep Pattern")
plt.show()

def sum_nested_list(nested_list):
    total = 0
    for item in nested_list:
        if isinstance(item, list):
            total += sum_nested_list(item)
        else:
            total += item
    return total

nested = [1, [2, [3, 4], 5], 6, [7, 8]]
print("Sum =", sum_nested_list(nested))

def generate_permutations(s):
    if len(s) == 0:
        return [""]

    perms = []

    for i in range(len(s)):
        remaining = s[:i] + s[i+1:]
        for p in generate_permutations(remaining):
            new_perm = s[i] + p

            if new_perm not in perms:  # prevent duplicates
                perms.append(new_perm)

    return perms

print(generate_permutations("abc"))
print(generate_permutations("aab"))

def calculate_directory_size(directory):
    total = 0
    for key, value in directory.items():
        if isinstance(value, dict):
            total += calculate_directory_size(value)
        else:
            total += value
    return total


directory_structure = {
    "file1.txt": 200,
    "file2.txt": 300,
    "subdir1": {
        "file3.txt": 400,
        "file4.txt": 100
    },
    "subdir2": {
        "subsubdir1": {
            "file5.txt": 250
        },
        "file6.txt": 150
    }
}

print("Total directory size =", calculate_directory_size(directory_structure))

def min_coins(coins, amount):
    dp = [float("inf")] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    if dp[amount] == float("inf"):
        return -1

    return dp[amount]


print(min_coins([1, 2, 5], 11))  # expected 3

def longest_common_subsequence(s1, s2):
    n = len(s1)
    m = len(s2)

    dp = [[0] * (m + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[n][m]


print(longest_common_subsequence("abcde", "ace"))  # expected 3

def knapsack(weights, values, capacity):
    n = len(weights)

    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        w = weights[i - 1]
        v = values[i - 1]

        for cap in range(1, capacity + 1):
            if w <= cap:
                dp[i][cap] = max(v + dp[i-1][cap-w], dp[i-1][cap])
            else:
                dp[i][cap] = dp[i-1][cap]

    return dp[n][capacity]


print(knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7))  # expected 9