# -*- coding: utf-8 -*-
"""Worksheet1.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vnksWE9L881X8ua0oWCcqHOIQbVjJxeM

PROBLEM 1 -ARRAY CREATION
"""

import numpy as np

empty_arr = np.empty((2,2))
print(empty_arr)

ones_arr = np.ones((4,2))
print(ones_arr)

filled_arr = np.full((3,3), 7)
print(filled_arr)

a = np.array([[1,2,3],[4,5,6]])
zeros_like_a = np.zeros_like(a)
print(zeros_like_a)

ones_like_a = np.ones_like(a)
print(ones_like_a)

new_list = [1,2,3,4]
arr = np.array(new_list)
print(arr)

"""PROBLEM 2 - ARRAY MANIPULATION"""

arr = np.arange(10, 50)
print(arr)

mat = np.arange(9).reshape(3,3)
print(mat)

I = np.eye(3)
print(I)

rand30 = np.random.random(30)
print("Mean:", rand30.mean())

rand10 = np.random.random((10,10))
print(rand10.min(), rand10.max())

z = np.zeros(10)
z[4] = 1
print(z)

arr = np.array([1,2,0,0,4,0])
rev = arr[::-1]
print(rev)

x = np.ones((5,5), dtype=int)
x[1:-1, 1:-1] = 0
print(x)

checker = np.zeros((8,8), dtype=int)
checker[::2,1::2] = 1
checker[1::2,::2] = 1
print(checker)

"""PROBLEM 3 - ARRAY OPERATIONS"""

x = np.array([[1,2],[3,5]])
y = np.array([[5,6],[7,8]])
v = np.array([9,10])
w = np.array([11,12])

print(x + y)

print(x - y)

print(x * 3)

print(x ** 2)

print(np.dot(v, w))

print(np.dot(x, v))

print(np.dot(x, y))

print(np.concatenate((x, y), axis=0))

print(np.column_stack((v, w)))

v2 = v.reshape(1,2)
np.concatenate((x, v2), axis=0)

"""PROBLEM 4 - MATRIX OPERATIONS"""

A = np.array([[3,4],[7,8]])
B = np.array([[5,3],[2,1]])

import numpy as np

A = np.array([[3., 4.],
              [7., 8.]])
A_inv = np.linalg.inv(A)

# product
prod = A @ A_inv

print("A_inv:\n", A_inv)
print("\nA @ A_inv:\n", np.round(prod, 8))
print("\nIs close to identity?:", np.allclose(prod, np.eye(2)))


B = np.array([[5., 3.],
              [2., 1.]])

AB = A @ B
BA = B @ A

print("A @ B:\n", AB)
print("\nB @ A:\n", BA)
print("\nAre AB and BA equal? ->", np.array_equal(AB, BA))
print("Are AB and BA approximately equal? ->", np.allclose(AB, BA))


lhs = (A @ B).T
rhs = B.T @ A.T

print("(AB)^T:\n", lhs)
print("\nB^T @ A^T:\n", rhs)
print("\nEquality check (allclose):", np.allclose(lhs, rhs))


M = np.array([[2., -3., 1.],
              [1., -1., 2.],
              [3.,  1., -1.]])
b = np.array([-1., -3., 9.])


sol_solve = np.linalg.solve(M, b)
print("Solution with np.linalg.solve:", sol_solve)

M_inv = np.linalg.inv(M)
sol_inverse = M_inv @ b
print("Solution with inverse method:", sol_inverse)

# Check they match
print("Same (allclose)?", np.allclose(sol_solve, sol_inverse))

# determinant (to ensure matrix is invertible)
detM = np.linalg.det(M)
print("det(M) =", detM)

# residual to verify solution: M @ x - b should be ~0
residual = M @ sol_solve - b
print("Residual (should be near zero):", residual)

"""EXPERIMENT 4.2 - HOW FAST IS NUMPY?

Experiment 1
"""

import time
import numpy as np

N = 1_000_000

# Python lists
list_a = list(range(N))
list_b = list(range(N))

start = time.time()
list_add = [x + y for x, y in zip(list_a, list_b)]
end = time.time()

print("Python list addition time:", end - start, "seconds")

arr_a = np.arange(N)
arr_b = np.arange(N)

start = time.time()
np_add = arr_a + arr_b
end = time.time()

print("NumPy addition time:", end - start, "seconds")

"""Experiment 2"""

start = time.time()
list_mul = [x * y for x, y in zip(list_a, list_b)]
end = time.time()

print("Python list multiplication time:", end - start, "seconds")

start = time.time()
np_mul = arr_a * arr_b
end = time.time()

print("NumPy multiplication time:", end - start, "seconds")

"""Experiment 3"""

start = time.time()
list_dot = sum(x * y for x, y in zip(list_a, list_b))
end = time.time()

print("Python list dot product time:", end - start, "seconds")

start = time.time()
np_dot = np.dot(arr_a, arr_b)
end = time.time()

print("NumPy dot product time:", end - start, "seconds")

"""Experiment 4"""

size = 200

# Generate small matrices using python lists
A_list = [[(i + j) % 5 for j in range(size)] for i in range(size)]
B_list = [[(i * j) % 7 for j in range(size)] for i in range(size)]

def list_matmul(A, B):
    n = len(A)
    C = [[0]*n for _ in range(n)]
    for i in range(n):
        for k in range(n):
            for j in range(n):
                C[i][j] += A[i][k] * B[k][j]
    return C

start = time.time()
C_small = list_matmul(A_list, B_list)
end = time.time()

print(f"Python list matrix multiplication time ({size}×{size}):", end - start, "seconds")

size = 1000

A_np = np.random.rand(size, size)
B_np = np.random.rand(size, size)

start = time.time()
C_np = A_np @ B_np
end = time.time()

print(f"NumPy matrix multiplication time ({size}×{size}):", end - start, "seconds")